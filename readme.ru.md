# FileChangesWatcher

## Введение

По поводу отслеживания удаления файла: http://stackoverflow.com/questions/7861512/get-username-of-an-accesed-file?answertab=votes#tab-top
Действительно - без аудита системного журнала, где пишутся события удаления - не обойтись. Для правильной настройки аудита см.: https://gallery.technet.microsoft.com/scriptcenter/How-to-audit-changed-39afba72
http://www.intelliadmin.com/index.php/2008/03/use-auditing-to-track-who-deleted-your-files/

Приложение, которое следит за изменениями в указанных дисках/каталогах и на лету формирует список файлов и каталогов в которых произошли изменения.

![](images/1.png)

## Можно ли отследить процесс, который изменил файл?

Коротко - НЕТ.

http://ebanshi.cc/questions/4262160/is-it-possible-to-identify-what-process-is-changing-a-file-with-filesystemwatche

![](images/24.png)

## Примеры работы приложения.

Редактор иконок редактирует файл:

![](images/message.06.01.gif)

Слежение за файлом Excel:

![](images/message.07.01.gif)

Каждый файл в логе имеет такой же значек как и в проводнике windows explorer:

![](images/15.png)

## Описание приложения

Перед началом работы приложение определяет свои настройки из файла **FileChangesWatcher.ini** и определяет настройки:

1. Какие диски и каталоги надо мониторить?
2. Какие файлы по расширению надо мониторить?
3. Какие каталоги надо исключить из миниторинга?
4. Какие файлы (по началу имени) нужно пропускать?

### Описание параметров приложения

Параметры приложения можно открыть с помощью приложения:

![](images/7.png)

При этом запуститься редактор файлов ini по-умолчанию (обычно блокнот).

Параметры для настройки **п.1** указываются в секции [FoldersForWatch]:

![](images/2.png)

Обратите внимание, что ключи должны разными, и в одном ключе нельзя указывать больше одного каталога (это не регулярное выражение).
Имена ключей значения не имеют. Эти значения можно заносить вручную. При старте программа создаёт отдельный watcher для каждого каталога/диска
за которым она будет наблюдать. Но создаёт только для тех каталов, которые присутствуют на диске. Список каталогов, за которыми программа будет наблюдать
выдаётся после запуска программы:

![](images/4.png)

Параметры для настройки **п.2** указываются в серсии [Extensions]:

![](images/3.png)

Имена ключей должны быть разными. Однако в отличии от каталогов в одном ключе в этом разделе может быть указано несколько расширений. Разделителем у них является
символ вертикальной верты **"|"**. Расширения файлов приложение преобразует в регулярное выражение, суммируя ключи. В результате получается шаблон 
**^.*(\.ext1|\.ext2|...|\.ext3)$**. Имена ключей значения не имеют. Можно давать им осмысленные имена, чтобы понимать о каком пакете программ идёт речь.

Параметры для настройки **п.3** указываются в секции [FoldersForExceptions]

![](images/5.png)

Каждому ключу соответствует один каталог. Соответственно в одном ключе нельзя указать больше одного каталога. Когда операционная система
уведомляет программу, что обнаружено изменение, то FileChangesWatcher сначала проверяет, а не случилось ли изменение в каталоге, который
является исключением? Если да, то FileChangesWatcher игнорирует изменение. Имена каталогов-исключений не сравниваются просто как начало строк,
а проверяется, чтобы последние имена отличались и не принадлежали тому каталогу, который просто начинается на похожее имя. Например:

если настройка **folder6 = F:\Enternet\2016\16.05.24\del.01**, то каталог **F:\Enternet\2016\16.05.24\del.01\test** будет исключаться из наблюдения. 
Однако каталог **F:\Enternet\2016\16.05.24\del.01-копия** не будет исключаться из наблюдения, т.к. по сути он не является подкаталогом параметра folder6,
а просто находится с ним в одном каталоге.

Параметры **п.4** хранятся в секции [FileNamesExceptions]

![](images/6.png)

Эти параметры также перечисляются по-одиночке и не являются регулярными выражениями. Эти значения сравниваются только как начала строк имён файлов. Например,
**file01 = ~$** даст положительный ответ на файл **F:\docs\ ~$Договор.docx** (временный файл office).

### Описание меню управления приложением.

![](images/8.png)

## Работа с контекстным меню приложения

Чтобы работать с контекстным меню приложения надо это меню зарегистрировать с помощью меню управления приложением (Требуются права локального администратора):

![](images/9.png)

После регистрации в контекстном меню проводника Windows explorer появится меню FileChangesWatcher с подменю:

В контекстном меню на левой панели (Добавить каталог в секцию [FoldersForExceptions]):

![](images/10.png)

В контекстно меню каталога на правой панели (Добавить каталог в секцию [FoldersForExceptions])

![](images/11.png)

В контекстном меню на файлах (Добавить расширение файла в секцию [Extensions])

![](images/12.png)

Это позволяет упростить добавление соответствующих элементов в разделы настройки программы:

![](images/16.png)

После добавления нужно заново применить настройки (чтобы не перезагружать программу):

![](images/13.png)

Для отмены контестного меню проводника выберите пункт (UnRegister Windows Explorer Context menu) (Так же требуются права локального администратора):

![](images/14.png)

## Для разработчика

Для сборки проекта необходимо иметь доступ к Интернет, чтобы иметь возможность загрузить сторонние компоненты приложения.

### Запуск приложения на отладку в режиме контекстного меню проводника

Первый способ отладки приложения в таком режиме можно выполнить с помощью инструмента SharpShellTools. Хорошее описание: http://www.codeproject.com/Articles/512956/NET-Shell-Extensions-Shell-Context-Menus

Инструмент Server Manager, который описан в документе, ищите в каталоге, куда установлен компонент SharpShellTools:

![](images/28.png)

Второй способ отладки - выполнить подсоединение к процессу Explorer в Visual Studio:

- После сборки запустить приложение как .exe под администратором и выполнить регистрацию компонента:

![](images/17.png)

![](images/18.png)

В Visual Studio открыть диалоговое окно подсоединения к процессу:

![](images/19.png)

Выбрать/открыть Windows Explorer в котором будем тестировать компонент:

![](images/20.png)

Выполнить попытку вызова контекстного меню:

![](images/21.png)

До вызова контекстного меню вы должны получить переход в отладку и попасть в точку останова:

![](images/22.png)

### Сборка приложения после Register/Unregister компонента

После вызова функций приложения в проводнике файл FileChangesWatcher.exe оказывается заблокирован на запись и выполнить сборку приложения нельзя:

![](images/23.png)

Дело в том, что после запуска контекстного меню файл FileChangesWatcher.exe заблокирован windows explorer. Чтобы разблокировать этот файл нужно закрыть все
экземпляры windows explorer:

![](images/24.png)

Но при этом среди процессов они всё-таки остаются и их там так же надо закрыть:

![](images/25.png)

Повторяем сборку:

![](images/26.png)

Сборка выполнилась успешно. Снова запустим проводник:

![](images/27.png)

(Возможно, что именно по этой причине требуется перезагружать компьютер после uninstall приложений)


## RegisterAssembly

Обратить внимание на следующую особенность работы функции RegisterAssembly:

![](images/29.png)

Чтобы приложение нормально регистрировалось в windows explorer на платформах x64 обязательно нужно ОТКЛЮЧИТЬ настройку "prefer 32-bit":

![](images/30.png)

Если этого не сделать, то функция будет возвращать успешную регистрацию, однако по факту никакого подменю не появится.

## Настройка аудита для генерации событий удаления файлов и каталогов:

Включить систему аудита файлов (минимальная настройка для регистрации успешных событий):

run **secpol.msc**

![](images/31.png)

Настроить аудит файлов и каталогов, за которыми требуется установить наблюдение:

![](images/32.png)

После этого в журнале событий начнут появляться сообщения:

![](images/33.png)

Вот их программа и будет анализировать.

## Дополнительные материалы по теме.

Аудит удаления и доступа к файлам и запись событий в лог-файл средствами Powershell: https://habrahabr.ru/post/150149/

![](images/34.png)

Как открыть WPF WebBrowser страницу не по ссылке, а по содержимому: http://stackoverflow.com/questions/1598030/set-system-windows-controls-webbrowsers-content-to-a-static-html-literal?answertab=votes#tab-top

![](images/35.png)

C шарп.  Проверка существования элемента в коллекции по его значению: https://msdn.microsoft.com/ru-ru/library/bfed8bca%28v=vs.110%29.aspx?f=255&MSPPError=-2147217396

![](images/36.png)

Windows. Настройка политики безопасности Windows 10 Home Edition: http://winitpro.ru/index.php/2015/10/02/redaktor-gruppovyx-politik-dlya-windows-10-home-edition/

![](images/37.png)
